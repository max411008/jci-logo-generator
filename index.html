<script>
        // ==========================================
        // ▼▼▼ 參數設定區 (依照您的定位器數據) ▼▼▼
        // ==========================================
        const LOGO_CONFIG = {
            // 基準畫布寬度 (用來換算 px 與 %)
            baseWidth: 1000, 

            // 第一行設定
            line1: {
                xPercent: 11.9,   // X: 11.9%
                yPercent: 66.0,   // Y: 66% (Top)
                sizePx: 70,       // Size: 70px
                spacing: 0        // Spacing: 0px
            },

            // 第二行設定
            line2: {
                xPercent: 11.9,   // X: 11.9%
                yPercent: 74.9,   // Y: 74.9% (Top)
                sizePx: 70,       // Size: 70px
                spacing: 0        // Spacing: 0px
            }
        };
        // ==========================================
        // ▲▲▲ 設定結束 ▲▲▲
        // ==========================================

        let currentFont = null;
        let svgForPreview = ""; 
        let svgForDownload = "";

        window.onload = function() {
            opentype.load('PlusJakartaSans-Bold.ttf', function(err, font) {
                if (err) {
                    showError("字型載入失敗！請確認 'PlusJakartaSans-Bold.ttf' 檔案存在。");
                } else {
                    currentFont = font;
                    updatePreview();
                }
            });
        };

        function showError(msg) {
            const box = document.getElementById('error-box');
            box.style.display = 'block';
            box.innerHTML = msg;
        }

        async function updatePreview() {
            if (!currentFont) return;
            document.getElementById('error-box').style.display = 'none';

            const parts = document.getElementById('logoSelect').value.split('|');
            const fileName = parts[0]; 
            const bgColorToRemove = parts[1];
            const colorType = parts[2];

            document.getElementById('previewContainer').style.backgroundColor = bgColorToRemove;
            const colors = { 'jci-blue': '#0097D7', 'white': '#FFFFFF', 'black': '#1C1F2A' };
            const textColor = colors[colorType] || '#0097D7';

            try {
                const resp = await fetch(fileName);
                if (!resp.ok) throw new Error("讀取失敗: " + fileName);
                let rawSvg = await resp.text();

                const parser = new DOMParser();
                const docPreview = parser.parseFromString(rawSvg, "image/svg+xml");
                const docDownload = parser.parseFromString(rawSvg, "image/svg+xml");
                
                const svgElPreview = docPreview.documentElement;
                const svgElDownload = docDownload.documentElement;

                // 去背邏輯
                const elements = svgElDownload.querySelectorAll('path, rect, polygon, circle');
                elements.forEach(el => {
                    const fill = el.getAttribute('fill');
                    if (fill && fill.toLowerCase() === bgColorToRemove.toLowerCase()) {
                        el.remove();
                    }
                    if (bgColorToRemove.toLowerCase() === '#1c1f2a' && fill && fill.toLowerCase() === '#1c1f2a') {
                        el.remove();
                    }
                });

                // 尺寸標準化 (取得 SVG 真實寬高)
                let width = 1000, height = 665;
                if (!svgElPreview.getAttribute('viewBox')) {
                     svgElPreview.setAttribute('viewBox', `0 0 ${width} ${height}`);
                     svgElDownload.setAttribute('viewBox', `0 0 ${width} ${height}`);
                } else {
                     const vb = svgElPreview.getAttribute('viewBox').split(/[\s,]+/);
                     width = parseFloat(vb[2]);
                     height = parseFloat(vb[3]);
                }

                // 比例校正因子 (如果 SVG 原始不是 1000px 寬，按比例縮放參數)
                const scaleFactor = width / LOGO_CONFIG.baseWidth;

                // --- ★★★ 核心計算邏輯 (基於 Top-Left Anchor) ★★★ ---
                
                // === Line 1 計算 ===
                // X: 百分比轉座標
                const x1 = width * (LOGO_CONFIG.line1.xPercent / 100);
                
                // Size: px 轉當前 SVG 比例
                const size1 = LOGO_CONFIG.line1.sizePx * scaleFactor;
                
                // Y: 輸入的是 Top，Opentype 需要 Baseline
                // 算法： Top Y + FontSize = Baseline Y
                const topY1 = height * (LOGO_CONFIG.line1.yPercent / 100); 
                const baselineY1 = topY1 + size1; 

                // === Line 2 計算 ===
                const x2 = width * (LOGO_CONFIG.line2.xPercent / 100);
                const size2 = LOGO_CONFIG.line2.sizePx * scaleFactor;
                
                const topY2 = height * (LOGO_CONFIG.line2.yPercent / 100);
                const baselineY2 = topY2 + size2;

                const t1 = document.getElementById('chapterInput1').value;
                const t2 = document.getElementById('chapterInput2').value;

                // 繪製路徑
                const w1 = currentFont.getAdvanceWidth(t1, size1);
                // 警告檢查 (55% 為經驗值，可調整)
                document.getElementById('lengthWarning').style.display = (w1 > width * 0.55) ? 'block' : 'none';

                // Line 1 Path
                const p1 = currentFont.getPath(t1, x1, baselineY1, size1);
                p1.fill = textColor;
                const p1Svg = p1.toSVG(2);

                // Line 2 Path
                let p2Svg = "";
                if (t2.trim()) {
                    const p2 = currentFont.getPath(t2, x2, baselineY2, size2);
                    p2.fill = textColor;
                    p2Svg = p2.toSVG(2);
                }

                // 插入 SVG
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = p1Svg + p2Svg;
                
                const textNodesForPreview = tempDiv.cloneNode(true);
                while (textNodesForPreview.firstChild) {
                    svgElPreview.appendChild(textNodesForPreview.firstChild);
                }
                
                const textNodesForDownload = tempDiv.cloneNode(true);
                while (textNodesForDownload.firstChild) {
                    svgElDownload.appendChild(textNodesForDownload.firstChild);
                }

                const serializer = new XMLSerializer();
                svgForPreview = serializer.serializeToString(docPreview);
                svgForDownload = serializer.serializeToString(docDownload);
                
                document.getElementById('svg-preview-box').innerHTML = svgForPreview;

            } catch (err) {
                console.error(err);
                showError("讀取錯誤：" + err.message);
            }
        }

        async function downloadFile(type) {
            if (!svgForDownload) return;
            const btn = document.querySelector(`.btn-${type}`);
            const originalText = btn.innerText;
            btn.innerText = "生成中..."; btn.disabled = true;
            const name = "JCI_" + document.getElementById('chapterInput1').value;

            try {
                if (type === 'svg') {
                    const blob = new Blob([svgForDownload], {type: "image/svg+xml;charset=utf-8"});
                    triggerDownload(URL.createObjectURL(blob), name + ".svg");
                    alert("✅ SVG 下載成功！");
                } 
                else {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();
                    const scale = parseFloat(document.getElementById('sizeSelect').value);
                    const svgBlob = new Blob([svgForDownload], {type: "image/svg+xml;charset=utf-8"});
                    const url = URL.createObjectURL(svgBlob);

                    await new Promise((resolve, reject) => {
                        img.onload = resolve; img.onerror = reject; img.src = url;
                    });

                    // 使用 ViewBox 寬度計算
                    const vb = svgForDownload.match(/viewBox="[^"]+\s[^"]+\s([^"]+)\s([^"]+)"/);
                    const baseW = vb ? parseFloat(vb[1]) : 1000;
                    const baseH = vb ? parseFloat(vb[2]) : 665;

                    canvas.width = baseW * scale;
                    canvas.height = baseH * scale;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);

                    const pngData = canvas.toDataURL("image/png");
                    if (/Android|webOS|iPhone|iPad|iPod/i.test(navigator.userAgent)) {
                        const win = window.open();
                        win.document.write('<style>body{background:url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMCIgaGVpZ2h0PSIyMCI+PHBhdGggZD0iTTAgMGgxMHYxMEgwem0xMCAxMGgxMHYxMEgxMHoiIGZpbGw9IiNlZWUiLz48L3N2Zz4=") repeat; display:flex; justify-content:center; align-items:center; min-height:100vh; margin:0;}</style>');
                        win.document.write('<img src="' + pngData + '" style="max-width:100%; height:auto;"/>');
                        alert("✅ 圖片已生成！請長按儲存。");
                    } else {
                        triggerDownload(pngData, name + ".png");
                        alert("✅ PNG 下載成功");
                    }
                }
            } catch (e) {
                console.error(e);
                alert("❌ 錯誤：" + e.message);
            } finally {
                btn.innerText = originalText; btn.disabled = false;
            }
        }

        function triggerDownload(url, name) {
            const a = document.createElement('a');
            a.href = url;
            a.download = name;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            if (url.startsWith('blob:')) URL.revokeObjectURL(url);
        }
    </script>